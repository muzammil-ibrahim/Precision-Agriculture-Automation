"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
var _transformationMatrix = require("transformation-matrix");
var _eventFactory = _interopRequireDefault(require("./events/event-factory"));
var _pan = require("./features/pan");
var _common = require("./features/common");
var _interactions = require("./features/interactions");
var _parseViewBox = _interopRequireDefault(require("./utils/parseViewBox"));
var _interactionsTouch = require("./features/interactions-touch");
var _zoom = require("./features/zoom");
var _miniature = require("./features/miniature");
var _cursorPolyfill = _interopRequireDefault(require("./ui/cursor-polyfill"));
var _borderGradient = _interopRequireDefault(require("./ui/border-gradient"));
var _selection = _interopRequireDefault(require("./ui/selection"));
var _toolbar = _interopRequireDefault(require("./ui-toolbar/toolbar"));
var _detectTouch = _interopRequireDefault(require("./ui/detect-touch"));
var _miniature2 = _interopRequireDefault(require("./ui-miniature/miniature"));
var _constants = require("./constants");
var _migrationTips = require("./migration-tips");
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
function _extends() { return _extends = Object.assign ? Object.assign.bind() : function (n) { for (var e = 1; e < arguments.length; e++) { var t = arguments[e]; for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]); } return n; }, _extends.apply(null, arguments); }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == typeof i ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != typeof t || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != typeof i) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); } //events
//features
//ui
class ReactSVGPanZoom extends _react.default.Component {
  constructor(props, context) {
    const {
      width: viewerWidth,
      height: viewerHeight,
      scaleFactorMin,
      scaleFactorMax,
      children
    } = props;
    const {
      viewBox: SVGViewBox
    } = children.props;
    let defaultValue;
    if (SVGViewBox) {
      const [SVGMinX, SVGMinY, SVGWidth, SVGHeight] = (0, _parseViewBox.default)(SVGViewBox);
      defaultValue = (0, _common.getDefaultValue)(viewerWidth, viewerHeight, SVGMinX, SVGMinY, SVGWidth, SVGHeight, scaleFactorMin, scaleFactorMax);
    } else {
      const {
        width: SVGWidth,
        height: SVGHeight
      } = children.props;
      defaultValue = (0, _common.getDefaultValue)(viewerWidth, viewerHeight, 0, 0, SVGWidth, SVGHeight, scaleFactorMin, scaleFactorMax);
    }
    super(props, context);
    this.ViewerDOM = null;
    this.state = {
      pointerX: null,
      pointerY: null,
      defaultValue
    };
    this.autoPanLoop = this.autoPanLoop.bind(this);
    this.onWheel = this.onWheel.bind(this);
    if (process.env.NODE_ENV !== 'production') {
      (0, _migrationTips.printMigrationTipsRelatedToProps)(props);
    }
  }

  /** React hooks **/
  componentDidUpdate(prevProps) {
    const value = this.getValue();
    const props = this.props;
    let nextValue = value;
    let needUpdate = false;
    if (process.env.NODE_ENV !== 'production') {
      (0, _migrationTips.printMigrationTipsRelatedToProps)(props);
    }

    // This block checks the size of the SVG
    const {
      viewBox: SVGViewBox
    } = props.children.props;
    if (SVGViewBox) {
      // if the viewBox prop is specified
      const [x, y, width, height] = (0, _parseViewBox.default)(SVGViewBox);
      if (value.SVGMinX !== x || value.SVGMinY !== y || value.SVGWidth !== width || value.SVGHeight !== height) {
        nextValue = (0, _common.setSVGViewBox)(nextValue, x, y, width, height);
        needUpdate = true;
      }
    } else {
      // if the width and height props are specified
      const {
        width: SVGWidth,
        height: SVGHeight
      } = props.children.props;
      if (value.SVGWidth !== SVGWidth || value.SVGHeight !== SVGHeight) {
        nextValue = (0, _common.setSVGViewBox)(nextValue, 0, 0, SVGWidth, SVGHeight);
        needUpdate = true;
      }
    }

    // This block checks the size of the viewer
    if (prevProps.width !== props.width || prevProps.height !== props.height) {
      nextValue = (0, _common.setViewerSize)(nextValue, props.width, props.height);
      needUpdate = true;
    }

    // This blocks checks the scale factors
    if (prevProps.scaleFactorMin !== props.scaleFactorMin || prevProps.scaleFactorMax !== props.scaleFactorMax) {
      nextValue = (0, _common.setZoomLevels)(nextValue, props.scaleFactorMin, props.scaleFactorMax);
      needUpdate = true;
    }
    if (needUpdate) {
      this.setValue(nextValue);
    }
  }
  componentDidMount() {
    this.autoPanIsRunning = true;
    requestAnimationFrame(this.autoPanLoop);
    this.ViewerDOM.addEventListener('wheel', this.onWheel, false);
  }
  componentWillUnmount() {
    this.autoPanIsRunning = false;
    this.ViewerDOM.removeEventListener('wheel', this.onWheel);
  }

  /** ReactSVGPanZoom handlers **/
  getValue() {
    if ((0, _common.isValueValid)(this.props.value)) return this.props.value;
    return this.state.defaultValue;
  }
  getTool() {
    if (this.props.tool) return this.props.tool;
    return _constants.TOOL_NONE;
  }
  setValue(nextValue) {
    let {
      onChangeValue,
      onZoom,
      onPan
    } = this.props;
    if (onChangeValue) onChangeValue(nextValue);
    if (nextValue.lastAction) {
      if (onZoom && nextValue.lastAction === _constants.ACTION_ZOOM) onZoom(nextValue);
      if (onPan && nextValue.lastAction === _constants.ACTION_PAN) onPan(nextValue);
    }
  }

  /** ReactSVGPanZoom methods **/
  pan(SVGDeltaX, SVGDeltaY) {
    let nextValue = (0, _pan.pan)(this.getValue(), SVGDeltaX, SVGDeltaY);
    this.setValue(nextValue);
  }
  zoom(SVGPointX, SVGPointY, scaleFactor) {
    let nextValue = (0, _zoom.zoom)(this.getValue(), SVGPointX, SVGPointY, scaleFactor);
    this.setValue(nextValue);
  }
  fitSelection(selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight) {
    let nextValue = (0, _zoom.fitSelection)(this.getValue(), selectionSVGPointX, selectionSVGPointY, selectionWidth, selectionHeight);
    this.setValue(nextValue);
  }
  fitToViewer() {
    let SVGAlignX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _constants.ALIGN_LEFT;
    let SVGAlignY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _constants.ALIGN_TOP;
    let nextValue = (0, _zoom.fitToViewer)(this.getValue(), SVGAlignX, SVGAlignY);
    this.setValue(nextValue);
  }
  zoomOnViewerCenter(scaleFactor) {
    let nextValue = (0, _zoom.zoomOnViewerCenter)(this.getValue(), scaleFactor);
    this.setValue(nextValue);
  }
  setPointOnViewerCenter(SVGPointX, SVGPointY, zoomLevel) {
    let nextValue = (0, _common.setPointOnViewerCenter)(this.getValue(), SVGPointX, SVGPointY, zoomLevel);
    this.setValue(nextValue);
  }
  reset() {
    let nextValue = (0, _common.reset)(this.getValue());
    this.setValue(nextValue);
  }
  openMiniature() {
    let nextValue = (0, _miniature.openMiniature)(this.getValue());
    this.setValue(nextValue);
  }
  closeMiniature() {
    let nextValue = (0, _miniature.closeMiniature)(this.getValue());
    this.setValue(nextValue);
  }

  /** ReactSVGPanZoom internals **/
  handleViewerEvent(event) {
    let {
      props,
      ViewerDOM
    } = this;
    if (!([_constants.TOOL_NONE, _constants.TOOL_AUTO].indexOf(this.getTool()) >= 0)) return;
    if (event.target === ViewerDOM) return;
    let eventsHandler = {
      click: props.onClick,
      dblclick: props.onDoubleClick,
      mousemove: props.onMouseMove,
      mouseup: props.onMouseUp,
      mousedown: props.onMouseDown,
      touchstart: props.onTouchStart,
      touchmove: props.onTouchMove,
      touchend: props.onTouchEnd,
      touchcancel: props.onTouchCancel
    };
    let onEventHandler = eventsHandler[event.type];
    if (!onEventHandler) return;
    onEventHandler((0, _eventFactory.default)(event, props.value, ViewerDOM));
  }
  autoPanLoop() {
    let coords = {
      x: this.state.pointerX,
      y: this.state.pointerY
    };
    let nextValue = (0, _interactions.onInterval)(null, this.ViewerDOM, this.getTool(), this.getValue(), this.props, coords);
    if (this.getValue() !== nextValue) {
      this.setValue(nextValue);
    }
    if (this.autoPanIsRunning) {
      requestAnimationFrame(this.autoPanLoop);
    }
  }
  onWheel(event) {
    let nextValue = (0, _interactions.onWheel)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
    if (this.getValue() !== nextValue) this.setValue(nextValue);
  }

  /** React renderer **/
  render() {
    let {
      props,
      state: {
        pointerX,
        pointerY
      }
    } = this;
    let tool = this.getTool();
    let value = this.getValue();
    let {
      customToolbar: CustomToolbar = _toolbar.default,
      customMiniature: CustomMiniature = _miniature2.default
    } = props;
    let panningWithToolAuto = tool === _constants.TOOL_AUTO && value.mode === _constants.MODE_PANNING && value.startX !== value.endX && value.startY !== value.endY;
    let cursor;
    if (tool === _constants.TOOL_PAN) cursor = (0, _cursorPolyfill.default)(value.mode === _constants.MODE_PANNING ? 'grabbing' : 'grab');
    if (tool === _constants.TOOL_ZOOM_IN) cursor = (0, _cursorPolyfill.default)('zoom-in');
    if (tool === _constants.TOOL_ZOOM_OUT) cursor = (0, _cursorPolyfill.default)('zoom-out');
    if (panningWithToolAuto) cursor = (0, _cursorPolyfill.default)('grabbing');
    let blockChildEvents = [_constants.TOOL_PAN, _constants.TOOL_ZOOM_IN, _constants.TOOL_ZOOM_OUT].indexOf(tool) >= 0;
    blockChildEvents = blockChildEvents || panningWithToolAuto;
    const touchAction = this.props.detectPinchGesture || [_constants.TOOL_PAN, _constants.TOOL_AUTO].indexOf(this.getTool()) !== -1 ? 'none' : undefined;
    const style = {
      display: 'block',
      cursor,
      touchAction
    };
    return /*#__PURE__*/_react.default.createElement("div", {
      style: _objectSpread({
        position: "relative",
        width: value.viewerWidth,
        height: value.viewerHeight
      }, props.style),
      className: this.props.className
    }, /*#__PURE__*/_react.default.createElement("svg", {
      ref: ViewerDOM => this.ViewerDOM = ViewerDOM,
      width: value.viewerWidth,
      height: value.viewerHeight,
      style: style,
      onMouseDown: event => {
        let nextValue = (0, _interactions.onMouseDown)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onMouseMove: event => {
        let {
          left,
          top
        } = this.ViewerDOM.getBoundingClientRect();
        let x = event.clientX - Math.round(left);
        let y = event.clientY - Math.round(top);
        let nextValue = (0, _interactions.onMouseMove)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props, {
          x,
          y
        });
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.setState({
          pointerX: x,
          pointerY: y
        });
        this.handleViewerEvent(event);
      },
      onMouseUp: event => {
        let nextValue = (0, _interactions.onMouseUp)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onClick: event => {
        this.handleViewerEvent(event);
      },
      onDoubleClick: event => {
        let nextValue = (0, _interactions.onDoubleClick)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onMouseEnter: event => {
        if ((0, _detectTouch.default)()) return;
        let nextValue = (0, _interactions.onMouseEnterOrLeave)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
      },
      onMouseLeave: event => {
        let nextValue = (0, _interactions.onMouseEnterOrLeave)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
      },
      onTouchStart: event => {
        let nextValue = (0, _interactionsTouch.onTouchStart)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onTouchMove: event => {
        let nextValue = (0, _interactionsTouch.onTouchMove)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onTouchEnd: event => {
        let nextValue = (0, _interactionsTouch.onTouchEnd)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      },
      onTouchCancel: event => {
        let nextValue = (0, _interactionsTouch.onTouchCancel)(event, this.ViewerDOM, this.getTool(), this.getValue(), this.props);
        if (this.getValue() !== nextValue) this.setValue(nextValue);
        this.handleViewerEvent(event);
      }
    }, /*#__PURE__*/_react.default.createElement("rect", {
      fill: props.background,
      x: 0,
      y: 0,
      width: value.viewerWidth,
      height: value.viewerHeight,
      style: {
        pointerEvents: "none"
      }
    }), /*#__PURE__*/_react.default.createElement("g", {
      transform: (0, _transformationMatrix.toSVG)(value),
      style: blockChildEvents ? {
        pointerEvents: "none"
      } : {}
    }, /*#__PURE__*/_react.default.createElement("rect", {
      fill: this.props.SVGBackground,
      style: this.props.SVGStyle,
      x: value.SVGMinX || 0,
      y: value.SVGMinY || 0,
      width: value.SVGWidth,
      height: value.SVGHeight
    }), /*#__PURE__*/_react.default.createElement("g", null, props.children.props.children)), !([_constants.TOOL_NONE, _constants.TOOL_AUTO].indexOf(tool) >= 0 && props.detectAutoPan && value.focus) ? null : /*#__PURE__*/_react.default.createElement("g", {
      style: {
        pointerEvents: "none"
      }
    }, !(pointerY <= 20) ? null : /*#__PURE__*/_react.default.createElement(_borderGradient.default, {
      direction: _constants.POSITION_TOP,
      width: value.viewerWidth,
      height: value.viewerHeight
    }), !(value.viewerWidth - pointerX <= 20) ? null : /*#__PURE__*/_react.default.createElement(_borderGradient.default, {
      direction: _constants.POSITION_RIGHT,
      width: value.viewerWidth,
      height: value.viewerHeight
    }), !(value.viewerHeight - pointerY <= 20) ? null : /*#__PURE__*/_react.default.createElement(_borderGradient.default, {
      direction: _constants.POSITION_BOTTOM,
      width: value.viewerWidth,
      height: value.viewerHeight
    }), !(value.focus && pointerX <= 20) ? null : /*#__PURE__*/_react.default.createElement(_borderGradient.default, {
      direction: _constants.POSITION_LEFT,
      width: value.viewerWidth,
      height: value.viewerHeight
    })), !(value.mode === _constants.MODE_ZOOMING) ? null : /*#__PURE__*/_react.default.createElement(_selection.default, {
      startX: value.startX,
      startY: value.startY,
      endX: value.endX,
      endY: value.endY
    })), props.toolbarProps.position === _constants.POSITION_NONE ? null : /*#__PURE__*/_react.default.createElement(CustomToolbar, _extends({}, this.props.toolbarProps, {
      value: value,
      onChangeValue: value => this.setValue(value),
      tool: tool,
      onChangeTool: tool => this.props.onChangeTool(tool)
    })), props.miniatureProps.position === _constants.POSITION_NONE ? null : /*#__PURE__*/_react.default.createElement(CustomMiniature, _extends({}, this.props.miniatureProps, {
      value: value,
      onChangeValue: value => this.setValue(value),
      SVGBackground: this.props.SVGBackground
    }), props.children.props.children));
  }
}
exports.default = ReactSVGPanZoom;
ReactSVGPanZoom.propTypes = {
  /**************************************************************************/
  /*  Viewer configuration                                                  */
  /**************************************************************************/

  /**
   *   width of the viewer displayed on screen
   */
  width: _propTypes.default.number.isRequired,
  /**
  * height of the viewer displayed on screen
  */
  height: _propTypes.default.number.isRequired,
  /**
  * value of the viewer (current camera view)
  */
  value: _propTypes.default.oneOfType([_propTypes.default.object, _propTypes.default.shape({
    version: _propTypes.default.oneOf([2]).isRequired,
    mode: _propTypes.default.oneOf([_constants.MODE_IDLE, _constants.MODE_PANNING, _constants.MODE_ZOOMING]).isRequired,
    focus: _propTypes.default.bool.isRequired,
    a: _propTypes.default.number.isRequired,
    b: _propTypes.default.number.isRequired,
    c: _propTypes.default.number.isRequired,
    d: _propTypes.default.number.isRequired,
    e: _propTypes.default.number.isRequired,
    f: _propTypes.default.number.isRequired,
    viewerWidth: _propTypes.default.number.isRequired,
    viewerHeight: _propTypes.default.number.isRequired,
    SVGMinX: _propTypes.default.number.isRequired,
    SVGMinY: _propTypes.default.number.isRequired,
    SVGWidth: _propTypes.default.number.isRequired,
    SVGHeight: _propTypes.default.number.isRequired,
    startX: _propTypes.default.number,
    startY: _propTypes.default.number,
    endX: _propTypes.default.number,
    endY: _propTypes.default.number,
    miniatureOpen: _propTypes.default.bool.isRequired
  })]).isRequired,
  /**
  * handler something changed
  */
  onChangeValue: _propTypes.default.func.isRequired,
  /**
  * current active tool (TOOL_NONE, TOOL_PAN, TOOL_ZOOM_IN, TOOL_ZOOM_OUT)
  */
  tool: _propTypes.default.oneOf([_constants.TOOL_AUTO, _constants.TOOL_NONE, _constants.TOOL_PAN, _constants.TOOL_ZOOM_IN, _constants.TOOL_ZOOM_OUT]).isRequired,
  /**
  * handler tool changed
  */
  onChangeTool: _propTypes.default.func.isRequired,
  /**************************************************************************/
  /* Customize style                                                        */
  /**************************************************************************/

  /**
  * background of the viewer
  */
  background: _propTypes.default.string,
  /**
  * background of the svg
  */
  SVGBackground: _propTypes.default.string,
  /**
  * style of the svg
  */
  SVGStyle: _propTypes.default.object,
  /**
  * CSS style of the Viewer
  */
  style: _propTypes.default.object,
  /**
  * className of the Viewer
  */
  className: _propTypes.default.string,
  /**************************************************************************/
  /* Detect events                                                          */
  /**************************************************************************/

  /**
  * perform zoom operation on mouse scroll
  */
  detectWheel: _propTypes.default.bool,
  /**
  * perform PAN if the mouse is on viewer border
  */
  detectAutoPan: _propTypes.default.bool,
  /**
  * perform zoom operation on pinch gesture
  */
  detectPinchGesture: _propTypes.default.bool,
  /**
  * handler zoom level changed
  */
  onZoom: _propTypes.default.func,
  /**
  * handler pan action performed
  */
  onPan: _propTypes.default.func,
  /**
  * handler click
  */
  onClick: _propTypes.default.func,
  /**
  * handler double click
  */
  onDoubleClick: _propTypes.default.func,
  /**
  * handler mouseup
  */
  onMouseUp: _propTypes.default.func,
  /**
  * handler mousemove
  */
  onMouseMove: _propTypes.default.func,
  /**
  * handler mousedown
  */
  onMouseDown: _propTypes.default.func,
  /**************************************************************************/
  /* Some advanced configurations                                           */
  /**************************************************************************/

  /**
  * if disabled the user can move the image outside the viewer
  */
  preventPanOutside: _propTypes.default.bool,
  /**
  * how much scale in or out
  */
  scaleFactor: _propTypes.default.number,
  /**
  * how much scale in or out on mouse wheel (requires detectWheel enabled)
  */
  scaleFactorOnWheel: _propTypes.default.number,
  /**
  * maximum amount of scale a user can zoom in to
  */
  scaleFactorMax: _propTypes.default.number,
  /**
  * minimum amount of a scale a user can zoom out of
  */
  scaleFactorMin: _propTypes.default.number,
  /**
  * modifier keys //https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/getModifierState
  */
  modifierKeys: _propTypes.default.array,
  /**
  * Turn off zoom on double click
  */
  disableDoubleClickZoomWithToolAuto: _propTypes.default.bool,
  /**************************************************************************/
  /* Miniature configurations                                                 */
  /**************************************************************************/

  /**
  * override miniature component
  */
  customMiniature: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.func]),
  /**
  * miniature props
  */
  miniatureProps: _propTypes.default.shape({
    position: _propTypes.default.oneOf([_constants.POSITION_NONE, _constants.POSITION_RIGHT, _constants.POSITION_LEFT]),
    background: _propTypes.default.string,
    width: _propTypes.default.number,
    height: _propTypes.default.number
  }),
  /**************************************************************************/
  /* Toolbar configurations                                                 */
  /**************************************************************************/

  /**
  * override toolbar component
  */
  customToolbar: _propTypes.default.oneOfType([_propTypes.default.element, _propTypes.default.func]),
  /**
  * toolbar props
  */
  toolbarProps: _propTypes.default.shape({
    position: _propTypes.default.oneOf([_constants.POSITION_NONE, _constants.POSITION_TOP, _constants.POSITION_RIGHT, _constants.POSITION_BOTTOM, _constants.POSITION_LEFT]),
    SVGAlignX: _propTypes.default.oneOf([_constants.ALIGN_CENTER, _constants.ALIGN_LEFT, _constants.ALIGN_RIGHT]),
    SVGAlignY: _propTypes.default.oneOf([_constants.ALIGN_CENTER, _constants.ALIGN_TOP, _constants.ALIGN_BOTTOM]),
    activeToolColor: _propTypes.default.string
  }),
  /**************************************************************************/
  /* Children Check                                                         */
  /**************************************************************************/
  /**
  * accept only one node SVG
  */
  children: function (props, propName, componentName) {
    // Only accept a single child, of the appropriate type
    //credits: http://www.mattzabriskie.com/blog/react-validating-children
    let prop = props[propName];
    let types = ['svg'];
    if (_react.default.Children.count(prop) !== 1 || types.indexOf(prop.type) === -1) {
      return new Error('`' + componentName + '` ' + 'should have a single child of the following types: ' + ' `' + types.join('`, `') + '`.');
    }
    if ((!prop.props.hasOwnProperty('width') || !prop.props.hasOwnProperty('height')) && !prop.props.hasOwnProperty('viewBox')) {
      return new Error('SVG should have props `width` and `height` or `viewBox`');
    }
  }
};
ReactSVGPanZoom.defaultProps = {
  style: {},
  background: "#616264",
  SVGBackground: "#fff",
  SVGStyle: {},
  detectWheel: true,
  detectAutoPan: true,
  detectPinchGesture: true,
  modifierKeys: ["Alt", "Shift", "Control"],
  preventPanOutside: true,
  scaleFactor: 1.1,
  scaleFactorOnWheel: 1.06,
  disableZoomWithToolAuto: false,
  onZoom: null,
  onPan: null,
  toolbarProps: {},
  miniatureProps: {}
};